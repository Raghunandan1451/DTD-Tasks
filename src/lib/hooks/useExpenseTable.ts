// src/features/finance/expense_list/useExpenseTable.ts
import { useState, useRef, useEffect } from "react";
import { ExpenseEntry, ExpenseTableHandlers } from "@src/features/finance/type";
import { useConfirmationModal } from "@src/lib/hooks/useConfirmDialog";
import { ShowNotificationFn } from "@src/lib/types/downloadHandlerTypes";

const useExpenseTable = ({
	onEdit,
	onDelete,
	showNotification,
}: {
	onEdit: (e: ExpenseEntry) => void;
	onDelete: (id: string) => void;
	showNotification?: ShowNotificationFn;
}) => {
	const [editingId, setEditingId] = useState<string | null>(null);
	const [editForm, setEditForm] = useState<ExpenseEntry | null>(null);
	const editRowRef = useRef<HTMLTableRowElement | null>(null);

	// Add confirmation modal
	const confirmationModal = useConfirmationModal();

	const handleStartEdit = (expense: ExpenseEntry) => {
		if (expense.isAutoGenerated) return;
		setEditingId(expense.id);
		setEditForm({ ...expense });
	};

	const handleCancelEdit = () => {
		setEditingId(null);
		setEditForm(null);
	};

	const handleSaveEdit = () => {
		if (editForm) {
			onEdit(editForm);
			setEditingId(null);
			setEditForm(null);
		}
	};

	const handleEditChange = (
		field: keyof ExpenseEntry,
		value: string | number
	) => {
		if (editForm) {
			setEditForm({
				...editForm,
				[field]:
					field === "amount"
						? parseFloat(value as string) || 0
						: field === "quantity"
						? parseInt(value as string, 10) || 0
						: value,
			});
		}
	};

	const handleDelete = async (
		id: string,
		name: string,
		isAutoGenerated: boolean
	) => {
		if (isAutoGenerated) {
			showNotification?.(
				"Auto-generated salary entries cannot be deleted. Update your salary settings instead.",
				"info"
			);
			return;
		}

		const confirmed = await confirmationModal.confirm({
			title: "Delete Expense",
			message:
				"Are you sure you want to delete this expense? This action cannot be undone.",
			itemName: name,
			confirmText: "Delete",
			cancelText: "Cancel",
			type: "danger",
		});

		if (confirmed) {
			onDelete(id);
		}
	};

	// Additional method for Budget Simulator
	const handleRemoveItem = async (id: string, name?: string) => {
		const confirmed = await confirmationModal.confirm({
			title: "Remove Item",
			message:
				"Are you sure you want to remove this item from the simulation?",
			itemName: name,
			confirmText: "Remove",
			cancelText: "Cancel",
			type: "danger",
		});

		if (confirmed) {
			onDelete(id);
		}
	};

	const handleKeyDown = (e: React.KeyboardEvent<HTMLElement>) => {
		if (e.key === "Enter") {
			e.preventDefault();
			const editRow = editRowRef.current;
			if (editRow) {
				const inputs = Array.from(
					editRow.querySelectorAll<HTMLElement>("input, select")
				).filter((el) => !el.hasAttribute("disabled"));
				const currentIndex = inputs.indexOf(
					e.currentTarget as HTMLElement
				);
				if (currentIndex < inputs.length - 1) {
					inputs[currentIndex + 1].focus();
				} else {
					handleSaveEdit();
				}
			}
		}
		if (e.key === "Escape") {
			handleCancelEdit();
		}
	};

	useEffect(() => {
		if (editingId && editRowRef.current) {
			const firstInput =
				editRowRef.current.querySelector<HTMLInputElement>("input");
			if (firstInput) {
				setTimeout(() => firstInput.focus(), 50);
			}
		}
	}, [editingId]);

	const displayQuantity = (quantity: number, unit: string) => {
		if (isNaN(quantity) || !quantity || !unit) return "-";
		return `${quantity} ${unit}`;
	};

	return {
		editingId,
		editForm,
		editRowRef,
		confirmationModal, // Expose modal for rendering
		handlers: {
			handleStartEdit,
			handleCancelEdit,
			handleSaveEdit,
			handleEditChange,
			handleDelete,
			handleRemoveItem, // Add this for Budget Simulator
			handleKeyDown,
			displayQuantity,
		} as ExpenseTableHandlers & {
			handleRemoveItem: (id: string, name?: string) => Promise<void>;
		},
	};
};

export default useExpenseTable;
