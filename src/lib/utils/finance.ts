// import { TimeUnit } from "@src/lib/types/finance";

import {
	DatedSalary,
	ExpenseEntry,
	FinanceState,
} from "@src/features/finance/type";
import { AppDispatch } from "@src/lib/store/store";
import { setFinanceState } from "@src/lib/store/slices/financeSlice";
import { addExpense } from "@src/lib/store/slices/expensesSlice";

interface FinanceFormValues {
	amount: string;
	day: string;
	balance?: string;
}
export const validateFinanceSetup = ({
	amount,
	day,
	balance,
}: FinanceFormValues): { success: boolean; message: string } => {
	if (!amount || parseFloat(amount) <= 0) {
		return {
			success: false,
			message: "Salary amount must be greater than 0.",
		};
	}

	const dayVal = parseInt(day);
	if (!day || dayVal < 1 || dayVal > 31) {
		return {
			success: false,
			message: "Day of month must be between 1 and 31.",
		};
	}

	if (!balance || isNaN(parseFloat(balance))) {
		return { success: false, message: "Current balance is required." };
	}

	return { success: true, message: "Finance setup is valid." };
};

export function computeAutoUpdatedBalance(
	finance: FinanceState
): FinanceState | null {
	const today = new Date();
	const todayDate = today.getDate();

	if (!finance.salary?.amount || !finance.salary.dayOfMonth) return null;

	if (todayDate < finance.salary.dayOfMonth) return null;

	const lastUpdate = finance.lastUpdatedDate
		? new Date(finance.lastUpdatedDate)
		: null;

	let monthsPassed = 1;

	if (lastUpdate) {
		const yearDiff = today.getFullYear() - lastUpdate.getFullYear();
		const monthDiff = today.getMonth() - lastUpdate.getMonth();
		monthsPassed = yearDiff * 12 + monthDiff;

		if (monthsPassed < 1) return null;
	}

	const todayISO = today.toISOString().split("T")[0];

	return {
		...finance,
		currentBalance:
			finance.currentBalance + finance.salary.amount * monthsPassed,
		lastUpdatedDate: todayISO,
	};
}

export function autoUpdateBalance(
	finance: FinanceState,
	dispatch: AppDispatch
) {
	const updated = computeAutoUpdatedBalance(finance);
	if (updated) {
		dispatch(setFinanceState(updated));
	}
}

const getSalaryCreditDate = (
	year: number,
	month: number,
	dayOfMonth: number
): string => {
	const lastDayOfMonth = new Date(year, month + 1, 0).getDate();
	const actualDay = Math.min(dayOfMonth, lastDayOfMonth);

	const monthStr = (month + 1).toString().padStart(2, "0");
	const dayStr = actualDay.toString().padStart(2, "0");
	const dateStr = `${year}-${monthStr}-${dayStr}`;

	return dateStr;
};

export const addSalaryForMissedMonths = (
	salary: DatedSalary,
	expenses: ExpenseEntry[],
	dispatch: AppDispatch,
	finance: FinanceState,
	lookbackMonths: number = 6
): number => {
	if (!salary || !salary.amount || !salary.dayOfMonth) return 0;
	const today = new Date();
	const salariesToAdd: Array<{ date: string; amount: number; name: string }> =
		[];

	const lastUpdatedDate = finance.lastUpdatedDate
		? new Date(finance.lastUpdatedDate)
		: null;

	for (let monthsBack = 0; monthsBack < lookbackMonths; monthsBack++) {
		const checkYear = today.getFullYear();
		const checkMonth = today.getMonth() - monthsBack;

		const actualYear = checkMonth < 0 ? checkYear - 1 : checkYear;
		const actualMonth = checkMonth < 0 ? 12 + checkMonth : checkMonth;

		const salaryDateStr = getSalaryCreditDate(
			actualYear,
			actualMonth,
			salary.dayOfMonth
		);
		const salaryCreditDate = new Date(salaryDateStr + "T12:00:00");

		if (lastUpdatedDate && salaryCreditDate < lastUpdatedDate) continue;

		if (salaryCreditDate <= today) {
			const existingSalary = expenses.find(
				(expense) =>
					expense.date === salaryDateStr &&
					expense.type === "Cr" &&
					expense.isAutoGenerated === true &&
					expense.group === "Salary"
			);

			if (!existingSalary) {
				const salaryName = `Salary - ${salaryCreditDate.toLocaleDateString(
					"en-GB",
					{
						month: "short",
						year: "numeric",
					}
				)}`;

				salariesToAdd.push({
					date: salaryDateStr,
					amount: salary.amount,
					name: salaryName,
				});
			}
		}
	}

	salariesToAdd.forEach(({ date, amount, name }) => {
		dispatch(
			addExpense({
				name,
				amount,
				date,
				group: "Salary",
				type: "Cr",
				isAutoGenerated: true,
				quantity: 1,
				unit: "month",
			})
		);
	});

	return salariesToAdd.length;
};
